#!/usr/bin/python3
#
# BTTS - BlueTooth Test Suite
#
# Copyright (C) 2014 Jolla Ltd.
# Contact: Martin Kampas <martin.kampas@jollamobile.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 2.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import dbus
import dbus.mainloop.glib
from   gi.repository import GObject
import sys

import btts
from   btts.cliutils import failure_on, bad_usage_on, error_handler
from   btts.utils import dbus_service_method, dbus_service_signal

SAMPLE_PATH = '/tmp/btts-hfp-sample'
SAMPLE_CODE_PATH = '/tmp/btts-hfp-sample.code'
SAMPLE_MAX_SIZE = 50 << 20 # Bytes
ECHO_PATH = '/tmp/btts-hfp-echo.wav'

SERVER_BUS_NAME = 'org.merproject.btts.HfpTool'
SERVER_PATH = '/org/merproject/btts/HfpTool'
SERVER_INTERFACE = 'org.merproject.btts.HfpTool'

class Server(dbus.service.Object):
    def __init__(self, bus, path):
        dbus.service.Object.__init__(self, bus, path)
        self._player = btts.Player()
        self._recorder = btts.Recorder()

    @dbus_service_method(SERVER_INTERFACE,
                         in_signature="i", out_signature="")
    def StartPlayBackAndRecord(self, duration):
        self._recorder.start(ECHO_PATH, duration)
        self._player.start(SAMPLE_PATH, duration)

    @dbus_service_method(SERVER_INTERFACE,
                         in_signature="", out_signature="")
    def WaitPlayBackAndRecord(self):
        self._player.wait()
        self._recorder.wait()

class CommandEnabled:
    '''\
    Get/Set profile enabled state.

    With no argument it prints "true" or "false" to indicate current state.
    '''

    def __init__(self, subparsers):
        parser = subparsers.add_parser(
                'enabled',
                help='Get/Set profile enabled state',
                formatter_class=argparse.RawDescriptionHelpFormatter,
                description=self.__doc__)
        parser.add_argument(
                'enabled', nargs='?', type=btts.cliutils.boolean,
                help='Profile enabled state (true|false)')
        parser.set_defaults(handler=self)

    @failure_on([btts.ProfileManager.Error])
    def __call__(self, server, args):
        profile_manager = btts.ProfileManager()

        if args.enabled == None:
            state = profile_manager.get_profiles_state()['hfp']
            print(['false', 'true'][state])
        else:
            profile_manager.enable_profile('hfp', args.enabled)

class CommandSetSample:
    '''\
    Set audio sample for HFP testing.

    The audio sample is read from stdin.
    '''

    def __init__(self, subparsers):
        parser = subparsers.add_parser(
                'set-sample',
                help='Set audio sample for HFP testing',
                formatter_class=argparse.RawDescriptionHelpFormatter,
                description=self.__doc__)
        parser.set_defaults(handler=self)

    def __call__(self, server, args):
        with open(SAMPLE_PATH, 'wb') as sample_file:
            btts.utils.sendfile(sample_file, sys.stdin.buffer, SAMPLE_MAX_SIZE)

        code = btts.Echonest.codegen(SAMPLE_PATH)
        with open(SAMPLE_CODE_PATH, 'w') as sample_code_file:
            sample_code_file.write(code)

class CommandAsyncPlayBackAndVerifyEcho:
    '''\
    Asynchronously play back the stored sample and match it with the echo.

    Assuming the HFP gateway has dialed an "echo service", it starts playing
    back the audio sample stored with `set-sample` command and simultaneously
    recording the echo. It will try to record exactly `duration' seconds of
    received audio data within `duration' + 30 seconds. Recorded echo will be
    matched against the played back sample.

    Use `async-play-back-and-verify-echo-wait` to query the result.
    '''

    def __init__(self, subparsers):
        parser = subparsers.add_parser(
                'async-play-back-and-verify-echo',
                help='Asynchronously play back the stored sample and match it with the echo',
                formatter_class=argparse.RawDescriptionHelpFormatter,
                description=self.__doc__)
        parser.add_argument('duration', nargs='?', type=int, default=20,
                            help='Record duration [secs]')
        parser.set_defaults(handler=self)

    @failure_on([btts.Player.Error, btts.Recorder.Error])
    def __call__(self, server, args):
        server.StartPlayBackAndRecord(args.duration)

class CommandAsyncPlayBackAndVerifyEchoWait:
    '''\
    Match the asynchronously recorded echo against the played back sample.

    This command blocks until the asynchronous procedure started with
    `async-play-back-and-verify-echo` finishes and then matches the recorded audio
    against the played back sample.

    Prints "true" or "false" to indicate if the recorded echo matches the
    played back sample.

    Exits with non zero when echo of the given duration could not be recorded.
    '''

    def __init__(self, subparsers):
        parser = subparsers.add_parser(
                'async-play-back-and-verify-echo-wait',
                help='Match the asynchronously recorded echo against the played back sample',
                formatter_class=argparse.RawDescriptionHelpFormatter,
                description=self.__doc__)
        parser.set_defaults(handler=self)

    @failure_on([btts.Player.Error, btts.Recorder.Error])
    def __call__(self, server, args):
        server.WaitPlayBackAndRecord()

        with open(SAMPLE_CODE_PATH, 'r') as sample_code_file:
            sample_code = sample_code_file.read()

        code = btts.Echonest.codegen(ECHO_PATH)

        ok = btts.Echonest.match_code_string(wanted=sample_code,
                                             tested=code)
        print(['false', 'true'][ok])

# Main argument parser
main_parser = argparse.ArgumentParser(
        prog='btts hfp',
        description='Hands-Free Profile controlling utility.')
subparsers = main_parser.add_subparsers(
        dest='subcommand', title='subcommands',
        help='''Valid subcommands. Pass "<subcommand> --help" to get more help
            on the given subcommand.''')

CommandEnabled(subparsers)
CommandSetSample(subparsers)
CommandAsyncPlayBackAndVerifyEcho(subparsers)
CommandAsyncPlayBackAndVerifyEchoWait(subparsers)

main_parser.usage = '%(prog)s --server\n' + main_parser.format_usage()

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
bus = dbus.SystemBus()

if '--server' in sys.argv:
    if len(sys.argv) > 2:
        main_parser.error('Unexpected argument')

    mainloop = GObject.MainLoop()

    name = dbus.service.BusName(SERVER_BUS_NAME, bus)
    server = Server(bus, SERVER_PATH)

    # TODO: signal handling
    #signal.signal(signal.SIGINT,
    #		lambda *args: gobject.idle_add(mainloop.quit))
    #signal.signal(signal.SIGTERM,
    #		lambda *args: gobject.idle_add(mainloop.quit))

    mainloop.run()
else:
    args = main_parser.parse_args()
    if not args.subcommand:
        main_parser.print_usage()
        sys.exit(1)

    server_object = bus.get_object(SERVER_BUS_NAME, SERVER_PATH)
    server = dbus.Interface(server_object, SERVER_INTERFACE)

    with error_handler(main_parser):
        args.handler(server, args)
